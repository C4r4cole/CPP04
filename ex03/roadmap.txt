Lâ€™objectif du main : vÃ©rifier polymorphisme + ownership + deep copy + comportement â€œrien ne se passeâ€ + pas de leaks/crash.

0) PrÃ©-requis (important)

Avant de tester, assure-toi que :

Character delete bien ce quâ€™il possÃ¨de (inventaire + floor) âœ…

MateriaSource delete bien ses templates âœ…

createMateria() retourne un clone âœ…

unequip() ne delete pas âœ…

1) Test â€œbasiqueâ€ du sujet (celui qui ressemble au PDF 42)
ScÃ©nario

crÃ©er une MateriaSource

lui faire apprendre ice et cure

crÃ©er un Character â€œmeâ€

crÃ©er une materia â€œiceâ€ via la source

lâ€™Ã©quiper

lâ€™utiliser sur â€œbobâ€

Pseudo-code

IMateriaSource* src = new MateriaSource();

src->learnMateria(new Ice());

src->learnMateria(new Cure());

ICharacter* me = new Character("me");

ICharacter* bob = new Character("bob");

AMateria* tmp = src->createMateria("ice");

me->equip(tmp);

me->use(0, *bob); â†’ doit afficher â€œshoots an ice boltâ€¦â€

tmp = src->createMateria("cure");

me->equip(tmp);

me->use(1, *bob); â†’ doit afficher â€œheals bobâ€™s woundsâ€

delete bob; delete me; delete src;

âœ… Ã‡a valide : learnMateria, createMateria, equip, use, destructeurs virtuels.

âš ï¸ Note : learnMateria(new Ice()) crÃ©e un objet qui nâ€™est pas delete par toi. Dans ta version, MateriaSource clone mais ne delete pas lâ€™argument, donc le new Ice() initial fuit si tu fais Ã§a tel quel.
Deux options de test :

soit tu acceptes une mini fuite dans le main (souvent tolÃ©rÃ©e dans les tests â€œsubject-likeâ€, mais pas top)

soit tu fais : stocker le pointeur, learnMateria(p), puis delete p; juste aprÃ¨s (puisque la source a clonÃ©).

2) Test â€œinventory pleinâ€ + â€œidx invalideâ€ (doit ne rien faire)
Ã€ tester

equipping 5 materias â†’ la 5e ne doit pas entrer

use(42, bob) ne doit pas crash

unequip(-1) / unequip(3) quand vide â†’ rien

IdÃ©es

crÃ©e 5 materias via createMateria("ice") (ou mix)

Ã©quipe-les dans me

tente une 5e equip (ne doit pas prendre)

appelle use(3, bob) (doit marcher si slot rempli)

appelle use(4, bob) (rien)

appelle use(-1, bob) (rien)

3) Test â€œtype inconnuâ€ (createMateria doit retourner 0)

AMateria* x = src->createMateria("fire");

vÃ©rifier que x == 0 et surtout ne pas lâ€™Ã©quiper / ne pas delete si câ€™est 0.

4) Test â€œunequip ne delete pasâ€ + gestion du â€œfloorâ€

Ton Character met au sol puis delete au destructeur. Donc tu veux vÃ©rifier :

aprÃ¨s unequip, le slot devient vide

use(slot, bob) ne fait rien

pas de crash Ã  la fin (delete de Character nettoie le floor)

SÃ©quence

Ã©quipe une materia en slot 0

me->use(0, bob) marche

me->unequip(0)

me->use(0, bob) ne fait rien

fin du programme : pas de leak/crash (floor bien dÃ©truit)

5) Test deep copy de Character (le plus important)

Tu veux prouver :

les pointeurs des materias Ã©quipÃ©es dans la copie sont diffÃ©rents

mais le comportement est identique

et pas de double delete

SÃ©quence

Character original("orig");

Ã©quipe 2 materias crÃ©Ã©es via source (ice, cure)

Character copy(original); (copy ctor)

original.use(0, target) et copy.use(0, target) doivent afficher la mÃªme chose

ensuite : original.unequip(0);

copy.use(0, target) doit toujours marcher (preuve quâ€™il a sa propre materia)

fin : pas de crash

ğŸ‘‰ Pour la preuve â€œadresses diffÃ©rentesâ€, le plus clean est dâ€™ajouter temporairement un getter debug genre â€œadresse du slot iâ€ (const) ou une mÃ©thode debugInventory().

6) Test deep copy de MateriaSource

MÃªme logique :

MateriaSource a; apprend ice / cure

MateriaSource b(a);

b.createMateria("ice") doit marcher

destruction de a puis b : pas de crash

7) Checklist mÃ©moire (valgrind/leaks)

Tout createMateria() retourne un new via clone â†’ il doit Ãªtre possÃ©dÃ© par un Character (et donc delete Ã  la fin), ou bien delete dans le main si non Ã©quipÃ©.

Si tu fais learnMateria(new Ice()) et que learnMateria clone sans delete lâ€™argument : tu leak lâ€™argument si tu ne le deletes pas toi-mÃªme.

Mini-consigne pour toi (pratique)

Ã‰cris ton main en 4 blocs sÃ©parÃ©s par des prints du style :

std::cout << "\n=== Basic subject test ===\n";

std::cout << "\n=== Edge cases ===\n";

std::cout << "\n=== Deep copy Character ===\n";

std::cout << "\n=== Deep copy MateriaSource ===\n";

Comme Ã§a tu lis facilement la sortie.

Si tu me dis comment tu gÃ¨res learnMateria dans ton main :

A) tu acceptes la fuite des new Ice() donnÃ©s Ã  learnMateria

B) tu stockes le pointeur et tu delete juste aprÃ¨s learnMateria (propre)

â€¦je te propose une version de main â€œpseudo-code + ordre exact des opÃ©rationsâ€ adaptÃ©e, et je te dis aussi oÃ¹ mettre les delete pour Ã©viter tout leak.